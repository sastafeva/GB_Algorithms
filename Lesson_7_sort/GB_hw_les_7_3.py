# 3. Массив размером 2m + 1, где m — натуральное число, заполнен случайным образом. Найдите в массиве медиану.
# Медианой называется элемент ряда, делящий его на две равные части: в одной находятся элементы,
# которые не меньше медианы, в другой — не больше медианы.
# Примечание: задачу можно решить без сортировки исходного массива. Но если это слишком сложно,
# используйте метод сортировки, который не рассматривался на уроках (сортировка слиянием также недопустима).

# m - натуральное число, значит в массиве не меньше 3 элементов.
# Из определения медианы и длины массива следует, что в отсортированном массиве
# справа и слева от медианы будет по m элементов. А индекс медианы будет array[m].
# Поэтому можно отсортировать только половину списка.

from random import randint

m = int(input('Введите натуральное число: '))

size = 2 * m + 1
array = [randint(0, size) for i in range(size)]
print(f'Список из {2 * m + 1} случайных целых чисел', array, sep = '\n')


# Используем сортировку кучей (пирамидальная сортировка).
# Но я ее немного изменила. Например, остановила сортировку, когда медиана встала на свое место array[m]

# Создадим вспомогательную функцию.
def heapify(nums, heap_size, root_index):

    # Предположим, что индекс самого большого элемента является корневым индексом
    largest = root_index
    left_child = (2 * root_index) + 1
    right_child = (2 * root_index) + 2

    # Если левый потомок корня является допустимым индексом, а элемент больше
    # чем текущий самый большой элемент, то обновляем самый большой элемент
    if left_child < heap_size and nums[left_child] > nums[largest]:
        largest = left_child

    # Делаем то же самое для right_child
    if right_child < heap_size and nums[right_child] > nums[largest]:
        largest = right_child

    # Если самый большой элемент больше не является корневым элементом, меняем их местами
    if largest != root_index:
        nums[root_index], nums[largest] = nums[largest], nums[root_index]

        # Повторяем функцию с новым самым большим элементом, чтобы убедиться, что он самый большой
        heapify(nums, heap_size, largest)


def heap_sort(nums):
    n = len(nums)

    # Создаем Max Heap из списка
    # Двигаемся по списку с конца (точнее с элемента справа от середины)
    # Введем переменную start, чтобы сократить время сортировки.
    # Все, что больше start будет сравниваться с элементами, у которых индекс за пределами массива.
    start = (n-1) // 2
    for i in range(start, -1, -1):
        heapify(nums, n, i)

    # Перемещаем корень max heap в конец списка до тех пор, пока медиана не встанет на свое место
    for i in range(n - 1, m - 1, -1):
        nums[i], nums[0] = nums[0], nums[i]
        heapify(nums, i, 0)

# Проверяем, что все работает
heap_sort(array)
# print(array)
print(f'Первый вариант: Медиана данного списка равна {array[m]}.')



# ______________________________________________________________________________________________
# Написала функцию, потом увидела, что она слишком похожа на сортировку выбором.
# Оставила, как второй вариант.

# Будем находить самый маленький элемент и помещать его в начало списка.
# Следующий проход будет делать, не включая "отсортированную часть".
# Сортируем до тех пор, пока медиана не встанет на свое место

def mediana(array, ind = 0):
    min_el = array[ind]
    mark = False

    for i in range(ind+1, len(array)):
        if array[i] < min_el:
            min_el = array[i]
            index_min = i
            mark = True

    if mark:
        array[ind], array[index_min] = array[index_min], array[ind]

    if ind == m:
        return array[ind]
    else:
        ind += 1
        return mediana(array, ind = ind)

print(f'Второй вариант: Медиана данного списка равна {mediana(array)}.')



    

