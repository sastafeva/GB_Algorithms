# 3. Написать программу, которая обходит не взвешенный ориентированный граф без петель,
# в котором все вершины связаны, по алгоритму поиска в глубину (Depth-First Search).
# Примечания:
# a. граф должен храниться в виде списка смежности;
# b. генерация графа выполняется в отдельной функции, которая принимает на вход число вершин.

#__________________________________________________________
# Что понять, что значит "все вершины связаны" я прочитала разные источники
# и остановилась на презентации к уроку (слайд 12-13).
# Связный граф - это такой граф, где все вершины связаны (не каждая с каждой, а из любой вершины
# есть хотя бы один путь в другую вершину).
# Это же подтверждается иллюстрацией к 3 заданию на видео.
# Граф без петель означает, что нельзя вернуться в ту вершину, из которой вышел,
# не пройдя еще хотя бы одну вершину.
#__________________________________________________________

from random import shuffle, randint

# Добавляем проверку на корректность ввода данных
n = 1
m = 2

while n < 2 or m > (n-1):
    n = int(input('Введите количество вершин (больше 1): '))
    m = int(input('С какой вершины начинаем обход (от 0 до n-1): '))

    if n < 2:
        print('Количество вершин меньше 2. Введите заново.')
    elif m > (n-1):
        print(f'Стартовая вершина должна находиться в интервале от 0 до {n-1}')



# Сгенерируем список всех вершин
vertex = [i for i in range(n)]


# Функция генерации графа.
def graph(n):

    g = []

    # Цикл для генерации листов смежности
    for i in range(n):
        # Создаем перемешанную копию списка всех вершин.
        # Это нужно для генерации списка смежности, чтобы избежать повторений вершин.
        spam_1 = vertex.copy()
        shuffle(spam_1)
        spam = []

        # Повторяем генерацию смежного списка, пока в нем не будет хотя 1 значения, отличного от текущей вершины
        while spam == []:

            spam = [spam_1.pop() for _ in range(randint(1, n))]

            # убираем петли
            if i in spam:
                spam.remove(i)

        # добавляем в граф
        spam.sort()
        g.append(spam)

    return g

# Распечатаем полученный граф
g = graph(n)
print(*g, sep='\n')


# Функция обхода графа в глубину

# Создаем список посещенных вершин
visited = []


def dfs(g, start = m):

    # Добавляем в посещенные вершины start
    visited.append(start)

    # Запускаем рекурсивный цикл обхода графа в глубину
    for i in g[start]:
        if i not in visited:
            dfs(g, start=i)

    # Если из тех вершин, что мы обошли нет путей в какие-то вершины, то необходимо их тоже посетить.
    # В ориентированном графе такое может быть. В этом случае следующая вершина выбирается произвольно.
    if len(visited) < len(vertex):
        for i in range(len(g)):
            if i not in visited:
                dfs(g, start=i)


# Запустим функцию и распечатаем путь обхода графа в глубину
dfs(g)
print('Путь обхода графа в глубину: ', *visited, sep=' -> ')





