# 2. Закодируйте любую строку по алгоритму Хаффмана.
# _______________________________________________________________________________

# Строчные и заглавные буквы будут восприниматься, как разные.

from collections import Counter, deque


# Создадим класс для бинарных деревьев, как показано на уроке:
class MyNode:
    def __init__(self, left=None, right=None):
        self.left = left
        self.right = right


# Запросим строку, содержащую более 1 элемента
# Сделаем проверку, чтобы было больше 1 элемента для кодировки
s = ''
while len(s) < 2:

    s = input('Введите строку, которую нужно закодировать: ')

    if len(s) < 2:
        print('Введите строку, где более 1 символа')

# Посчитаем количество символов
count_s = Counter(s)

# Создадим очередь из отсортированного count_s.
# Сортировать будем по ключу = количество вхождений символа в строку
deq_s = deque(sorted(count_s.items(), key=lambda item: item[1]))


# Создадим дерево по алгоритму Хаффмана
# Будем извлекать по 2 элемента из начала очереди, объединять
# и вставлять обратно в соответствии с суммарным весом узла,
# пока не останется 1 элемент

def haf_tree(deq_s):

    while len(deq_s) > 1:

        # Считаем вес извлекаемых символов (по кол-ву вхождений)
        # и формируем узел, где слева и справа в листьях будут 2 символа из начала очереди
        weight = deq_s[0][1] + deq_s[1][1]
        node = MyNode(left=deq_s.popleft()[0], right=deq_s.popleft()[0])

        # Вставляем полученный узел обратно в очередь на место в соответствии с его весом
        for i in range(len(deq_s)):
            if weight > deq_s[i][1]:
                continue
            else:
                deq_s.insert(i, (node, weight))
                break

        # Если полученный вес - самый большой в очереди, добавляем его в конец
        else:
            deq_s.append((node, weight))


# Создадим таблицу кодов в словаре, и заполним его с помощью функции.
# Ключ - это символ из строки, а значение - его код.
map_s = {}


def haf_map(tree, path=''):

    # Если рекурсивно добрались до листа (где символ из строки)
    if not isinstance(tree, MyNode):
        map_s[tree] = path

    # Если находимся в узле, то спускаемся влево и вправо, увеличивая path
    else:
        haf_map(tree.left, path=f'{path}0')
        haf_map(tree.right, path=f'{path}1')


# Запустим функции
haf_tree(deq_s)
haf_map(deq_s[0][0])

# Напечатаем исходную строку в закодированном виде:
print('Строка, закодированная по алгоритму Хаффмана')
for i in s:
    print(map_s[i], end=' ')

print()

# Напечатаем таблицу кодов красиво:
print('Таблица кодов')
for k, v in map_s.items():
    print(k, ' : ', v)
